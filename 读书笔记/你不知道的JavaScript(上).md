## 第一部分 作用域和闭包

### 理解作用域

#### 编译原理

编译器对代码进行编译的过程主要分为三步骤： 

* 分词/词法分析： 将由字符组成的字符串分解成（对编程语言来说）有意义的代码块，分解成的代码块称为词法单元流。

* 解析/语法分析： 将词法单元流转换成 AST 抽象语法树。

* 代码生成： 将 AST 抽象语法树转换成可执行的代码。

JavaScript 程序分为编译阶段和执行阶段，代码需要先编译后执行，编译总是发生在执行之前的几微妙内，所以对 JavaScript 引擎的性能要求很高。


#### JavaScript 赋值操作

JavaScript 引擎是如何处理 JavaScript 代码的呢？比如： var a = 2;

* 首先在编译阶段，编译器会先询问作用域，在作用域集合中是否存在变量 a，如果存在则会忽略变量的声明，否则会要求作用域在当前的作用域集合中声明一个新变量，并命名为 a。

* 编译完成之后，进入到执行阶段，引擎在执行过程中，会先询问当前作用域中是否存在一个变量 a，存在的话就会使用这个变量，如果当前作用域中无法找到变量 a，就会往上一级作用域中继续查找，直到找到变量 a 或者查询完所有的作用域集合。

* 如果引擎中查找到变量 a，就会将 2 作为值赋值给变量 a。

#### 引擎查找

在执行阶段，引擎是如何在作用域的配合下查找变量的？引擎的查找方式有两种： RHS 和 LHS。

* RHS: 可以理解为目的是为了获取变量的值的查询方式，比如：```console.log(a)``` ，需要获取到变量 a 的值，使用的就是对变量 a 的 RHS 查询方式。
* LHS: 可以理解为目的是为了给变量赋值的查询方式，比如： ```a = 2;```  这样的赋值操作。

#### 作用域是什么

作用域其实是定义和查找变量的一套规则，用于存储变量，并且在之后可以方便的查找到变量。作用域存在层级关系，或者说是存在作用域嵌套。

引擎在执行代码时，RHS 和 LHS 查询都会从当前作用域开始，如果当前作用域中查找不到，就会逐级往上一层的作用域中查找，直到查找到了需要的变量或者到达了最顶级的作用域，引擎会终止查询。

RHS 和 LHS 查询结果差异：

* RHS 查询在作用域集合中查到不到变量，不成功的 RHS 查询会抛出 ReferenceError 异常。

* 非严格模式下，LHS 查询在作用域集合中查到不到变量，会在顶级作用域（全局作用域）内创建变量；严格模式下，会禁止自动或者隐式的创建全局变量，不成功的 LHS 查询会抛出 ReferenceError 异常。

  

### 词法作用域

词法作用域是作用域的工作模型中的一种，另一种是动态作用域。

词法作用域指的是作用域是由书写代码时函数声明的位置决定的，简单说就是代码写在哪，词法作用域就在哪。代码在编译过程中的词法分析阶段，就能够确定标识符的位置以及如何声明的，从而可以预测在执行阶段引擎如何对它们进行查找。

#### 欺骗词法

也存在通过某些方式来欺骗词法作用域，eval(...) 和 with。两者都是在运行时修改词法作用域，且在严格模式下两者的作用都将失效。前者可以对一段包含一个或多个声明的“代码”字符串进行演算，并借此来修改已经存在的词法作用域。后者本质上是通过将一个对象的引用当作作用域来处理,将对象的属性当作作用域中的标识符来处理，从而创建了一个新的词法作用域。

#### 性能

使用 eval(...) 和 with 都将带来性能方面的问题。为什么会这样？ JavaScript 引擎会在编译阶段进行性能优化，但是当遇到了 eval(...) 或 with 时，所有的性能优化将失效变得无意义，性能优化失效意味着代码执行将变得缓慢。eval 函数还会存在安全方面的问题，因为在编译阶段无法确定 eval 函数传入的字符串参数是怎样的，容易被篡改传入恶意攻击的代码。

#### 参考

关于 eval(...) 和 with 的更多知识参考链接：

* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Statements/with
* https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/eval
* [Why is using the JavaScript eval function a bad idea?](https://stackoverflow.com/questions/86513/why-is-using-the-javascript-eval-function-a-bad-idea)



### 函数作用域和块作用域 

#### 函数作用域

函数是 JavaScript 中最常见的作用域单元。每个函数都会为其自身创建一个作用域气泡，依附于作用域气泡的标识符都将隐藏在函数作用域中，无法从外部作用域访问。

将变量等标识符用函数包裹起来，使它们只能够作用在函数作用域内，可以有效的避免了变量名的冲突和污染以减少出错与维护的成本。软件设计中有一个最小暴露原则，就是最小限度地暴露必要的内容。

如何避免这样的冲突发生？ 一种解决方案就是使用全局命名空间。大多数 JavaScript 库都是采用这种方式，向外部只暴露出一个对象或者函数，所有的特性都依附在暴露对象的属性或者方法中。另一种就是采用模块化机制。

#### 块作用域

块作用域的作用就是将变量最大限度的本地化，而无需依附于外部的函数作用域。

ES6 之前，JavaScript 只有 with 和 try/catch 存在块作用域。最新的 ES6 标准中，let 和 const 声明的标识符都存在块作用域。